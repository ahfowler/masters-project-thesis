<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <!-- HTML Meta Tags -->
    <title>Room</title>

    <!-- Basic Three.js -->
    <script src="https://unpkg.com/three@0.133.0/build/three.js"></script>
    <!-- GLTF Loader for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Orbit Controls for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Reflector for Three.js -->
    <script src="https://unpkg.com/three@0.132.0/examples/js/objects/Reflector.js"></script>
    <!-- VRM Loader for Three.js -->
    <script src="https://unpkg.com/@pixiv/three-vrm@0.6.7/lib/three-vrm.js"></script>

    <!-- Kalidokit Solver -->
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1/dist/kalidokit.umd.js"></script>

    <!-- Socket.io -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"
        integrity="sha384-fKnu0iswBIqkjxrhQCTZ7qlLHOFEgNkRmK2vaO/LbTZSXdJfAu6ewRBdwHPhBo/H"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" href="./index.css">
    <script>
        var enterRoom;
    </script>
</head>

<body>
    <div id="enter-room">
        <p>Please enter your generated code:</p>
        <input type="text" id="user-code-input"></input>
        <a id="enter-button" onclick="enterRoom()">Enter</a>
    </div>
    <script type="module">
        import { VirtualRealityRoom } from "../../src/js/virtualreality.js";

        var circlePoints;
        let arrangeUsers;

        enterRoom = function enterRoom() {
            let generatedCode = document.getElementById("user-code-input").value;
            document.getElementById("enter-room").style.display = "none";

            let roomNumber = window.location.hash.substring(1);

            if (roomNumber) {
                document.title = "Room " + roomNumber;
                var currentRoom = new VirtualRealityRoom(roomNumber, generatedCode, (renderer, scene, camera) => {
                    console.log("Set up the scene...");
                    // scene.background = new THREE.Color(0xFFFFFF);

                    var viewport = camera.viewport;
                    if (viewport !== undefined) {
                        renderer.state.viewport(viewport);
                    }

                    let cameraControls;
                    let groundMirror, verticalMirror;
                    let geometry, material;

                    camera.position.set(0, 5.0, 20);

                    cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
                    cameraControls.target.set(0, 3.0, 0);
                    // cameraControls.maxDistance = 500;
                    // cameraControls.minDistance = 5;
                    cameraControls.update();

                    const planeGeo = new THREE.PlaneGeometry(100.1, 100.1);

                    // reflectors/mirrors
                    // Reflector does not work on mobile...

                    verticalMirror = new THREE.Reflector(planeGeo, {
                        textureWidth: window.innerWidth * window.devicePixelRatio,
                        textureHeight: window.innerHeight * window.devicePixelRatio
                    });

                    verticalMirror.position.y = 50;
                    verticalMirror.position.z = -20;
                    scene.add(verticalMirror);

                    // walls
                    const planeBack = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0x333333,
                    }));
                    planeBack.position.y = 50;
                    planeBack.position.z = -50;
                    scene.add(planeBack);

                    const planeTop = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE,
                    }));
                    planeTop.position.y = 100;
                    planeTop.rotateX(Math.PI / 2);
                    scene.add(planeTop);

                    const planeBottom = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE,
                    }));
                    planeBottom.rotateX(- Math.PI / 2);
                    scene.add(planeBottom);

                    const planeFront = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE,
                    }));
                    planeFront.position.z = 50;
                    planeFront.position.y = 50;
                    planeFront.rotateY(Math.PI);
                    scene.add(planeFront);

                    const planeRight = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE,
                    }));
                    planeRight.position.x = 50;
                    planeRight.position.y = 50;
                    planeRight.rotateY(- Math.PI / 2);
                    scene.add(planeRight);

                    const planeLeft = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE,
                    }));
                    planeLeft.position.x = - 50;
                    planeLeft.position.y = 50;
                    planeLeft.rotateY(Math.PI / 2);
                    scene.add(planeLeft);

                    // lights
                    const mainLight = new THREE.PointLight(0xcccccc, 1.5, 250);
                    mainLight.position.y = 60;
                    scene.add(mainLight);

                    const greenLight = new THREE.PointLight(0xEEEEEE, 0.25, 1000);
                    greenLight.position.set(550, 50, 0);
                    scene.add(greenLight);

                    const redLight = new THREE.PointLight(0xEEEEEE, 0.25, 1000);
                    redLight.position.set(- 550, 50, 0);
                    scene.add(redLight);

                    const blueLight = new THREE.PointLight(0xEEEEEE, 0.25, 1000);
                    blueLight.position.set(0, 50, 550);
                    scene.add(blueLight);

                    function animate() {
                        renderer.setAnimationLoop(animate);
                        // requestAnimationFrame(animate);

                        if (currentRoom && currentRoom.kalidokit && currentRoom.kalidokit.currentVrm) {
                            // Update model to render physics
                            currentRoom.kalidokit.currentVrm.update(currentRoom.kalidokit.clock.getDelta());
                        }

                        renderer.render(scene, camera);
                    }
                    animate();
                }, (kalidokitObject) => {
                    // This is called when the VirtualRealityRoom is created. (Connected users may not be loaded yet.)

                    arrangeUsers = () => {
                        if (currentRoom && currentRoom.connectedUsers) {
                            // console.log(currentRoom.connectedUsers);
                            // Step 1: Get all the socketIDs from the connected user.
                            let connectedUsers = Object.keys(currentRoom.connectedUsers)

                            // Step 2: Calculate positions for each user.
                            circlePoints = calculateCirclePoints(connectedUsers.length, 3, { x: 0, y: 0 });

                            let allUsersLoaded = true;
                            // console.log("Circle points...", circlePoints);
                            const checkUsers = setInterval(function () {
                                for (var i = 0; i < connectedUsers.length; i++) {
                                    var newUser = kalidokitObject.scene.getObjectByName(connectedUsers[i]);
                                    if (newUser) {
                                        newUser.rotation.set(0, 0, 0);
                                        newUser.position.x = 0.0;
                                        newUser.position.y = 0.0;
                                        newUser.position.z = 0.0;

                                        newUser.rotation.y = circlePoints[i].rotation + Math.PI;

                                        newUser.position.x = circlePoints[i].x;
                                        newUser.position.y = circlePoints[i].y;
                                        newUser.position.z = circlePoints[i].z;
                                    } else {
                                        allUsersLoaded = false;
                                    }
                                }

                                if (allUsersLoaded) {
                                    clearInterval(checkUsers);
                                }
                            }, 1000);
                        }
                    };
                    arrangeUsers();

                    currentRoom.onUserJoined((userSocketID) => {
                        if (arrangeUsers) {
                            arrangeUsers();
                        }
                    });

                    currentRoom.onUserLeft((userSocketID) => {
                        if (arrangeUsers) {
                            arrangeUsers();
                        }

                    });
                });

                currentRoom.loadUserOnJoin = true;
                currentRoom.unloadUserOnLeave = true;
            } else {
                // This is not a specific room?
            }
        };

        function calculateCirclePoints(numberPoints, radius, center) {
            // console.log(numberPoints, radius, center);
            let circlePoints = [];

            if (numberPoints < 2) {
                var point = { x: 0.0, y: 0.5, z: 0.0, rotation: 0.0 };
                circlePoints.push(point);
            } else {
                var slice = 2 * Math.PI / numberPoints;
                for (var i = 0; i < numberPoints; i++) {
                    var angle = slice * i;
                    var newX = center.x + radius * Math.cos(angle);
                    var newY = center.y + radius * Math.sin(angle);
                    // console.log(angle, newX, newY);
                    var point = { x: newX, y: 0.5, z: newY, rotation: slice * i };
                    circlePoints.push(point);
                }
            }

            Array.prototype.swap = function (a, b) {
                var tempX = this[a].x;
                var tempY = this[a].z;

                this[a].x = this[b].x;
                this[a].z = this[b].z;

                this[b].x = tempX;
                this[b].z = tempY;
                return this;
            };

            circlePoints = circlePoints.swap(0, numberPoints - 1);



            return circlePoints;
        }

    </script>
</body>

</html>
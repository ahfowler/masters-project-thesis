<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <!-- HTML Meta Tags -->
    <title>Room</title>

    <!-- Basic Three.js -->
    <script src="https://unpkg.com/three@0.133.0/build/three.js"></script>
    <!-- GLTF Loader for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Orbit Controls for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Reflector for Three.js -->
    <script src="https://unpkg.com/three@0.133.0/examples/js/objects/Reflector.js"></script>
    <!-- VRM Loader for Three.js -->
    <script src="https://unpkg.com/@pixiv/three-vrm@0.6.7/lib/three-vrm.js"></script>

    <!-- Kalidokit Solver -->
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1/dist/kalidokit.umd.js"></script>

    <!-- Socket.io -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"
        integrity="sha384-fKnu0iswBIqkjxrhQCTZ7qlLHOFEgNkRmK2vaO/LbTZSXdJfAu6ewRBdwHPhBo/H"
        crossorigin="anonymous"></script>
</head>

<body>
    <script type="module">
        import { VirtualRealityRoom } from "../../src/js/virtualreality.js";

        let roomNumber = window.location.hash.substring(1);
        if (roomNumber) {
            document.title = "Room " + roomNumber;
            var currentRoom = new VirtualRealityRoom(roomNumber, (renderer, scene, camera) => {
                console.log("Set up the scene...");
                scene.background = new THREE.Color("#ff0000");

                let cameraControls;
                let groundMirror, verticalMirror;
                let geometry, material;

                camera.position.set(0, 3.0, 2.0);

                cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
                cameraControls.target.set(0, 3.0, -25.0);
                cameraControls.maxDistance = 400;
                cameraControls.minDistance = 5;
                cameraControls.update();

                const planeGeo = new THREE.PlaneGeometry(100.1, 100.1);

                // reflectors/mirrors

                geometry = new THREE.CircleGeometry(30, 30);
                groundMirror = new THREE.Reflector(geometry, {
                    clipBias: 0.003,
                    textureWidth: window.innerWidth * window.devicePixelRatio,
                    textureHeight: window.innerHeight * window.devicePixelRatio,
                    color: 0x777777
                });
                groundMirror.position.y = 0.5;
                groundMirror.rotateX(- Math.PI / 2);
                scene.add(groundMirror);

                geometry = new THREE.PlaneGeometry(100, 100);
                verticalMirror = new THREE.Reflector(geometry, {
                    clipBias: 0.003,
                    textureWidth: window.innerWidth * window.devicePixelRatio,
                    textureHeight: window.innerHeight * window.devicePixelRatio,
                    color: 0x889999
                });
                verticalMirror.position.y = 50;
                verticalMirror.position.z = - 30;
                scene.add(verticalMirror);

                // walls
                const planeTop = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: "orange" }));
                planeTop.position.y = 100;
                planeTop.rotateX(Math.PI / 2);
                scene.add(planeTop);

                const planeBottom = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xffffff }));
                planeBottom.rotateX(- Math.PI / 2);
                scene.add(planeBottom);

                const planeFront = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0x7f7fff }));
                planeFront.position.z = 50;
                planeFront.position.y = 50;
                planeFront.rotateY(Math.PI);
                scene.add(planeFront);

                const planeRight = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                planeRight.position.x = 50;
                planeRight.position.y = 50;
                planeRight.rotateY(- Math.PI / 2);
                scene.add(planeRight);

                const planeLeft = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
                planeLeft.position.x = - 50;
                planeLeft.position.y = 50;
                planeLeft.rotateY(Math.PI / 2);
                scene.add(planeLeft);

                // lights
                const mainLight = new THREE.PointLight(0xcccccc, 1.5, 250);
                mainLight.position.y = 60;
                scene.add(mainLight);

                const greenLight = new THREE.PointLight(0x00ff00, 0.25, 1000);
                greenLight.position.set(550, 50, 0);
                scene.add(greenLight);

                const redLight = new THREE.PointLight(0xff0000, 0.25, 1000);
                redLight.position.set(- 550, 50, 0);
                scene.add(redLight);

                const blueLight = new THREE.PointLight(0x7f7fff, 0.25, 1000);
                blueLight.position.set(0, 50, 550);
                scene.add(blueLight);

                function animate() {
                    renderer.setAnimationLoop(animate);
                    // requestAnimationFrame(animate);

                    // if (currentVrm) {
                    //     // Update model to render physics
                    //     currentVrm.update(clock.getDelta());
                    // }

                    renderer.render(scene, camera);
                }
                animate();
            });

            currentRoom.onUserJoined((userSocketID) => {
                currentRoom.loadUser(userSocketID);
            });
        } else {
            // This is not a specific room?
        }
    </script>
</body>

</html>